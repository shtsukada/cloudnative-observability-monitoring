# ========== Contracts ==========
contracts:
  grafana:
    adminSecretName: "grafana-admin"
  datasources:
    enabled: true
    loki:
      url: &loki_url "http://loki.monitoring.svc:3100"
    tempo:
      url: &tempo_url "http://tempo.monitoring.svc:3200"
  logs:
    toLoki: true
  traces:
    toTempo: true
# ========== Global / Namespace ==========
global:
  namespace: monitoring

# ========== kube-prometheus-stack (alias: kps) ==========
kps:
  enabled: true
  fullnameOverride: kps
  defaultRules:
    create: true

  alertmanager:
    enabled: true

  grafana:
    enabled: true
    service:
      type: ClusterIP
    adminPassword: "admin"

    defaultDatasourceEnabled: true

    additionalDataSources:
      - name: Loki
        uid: loki
        type: loki
        access: proxy
        url: *loki_url
        isDefault: false
        jsonData: {}
      - name: Tempo
        uid: tempo
        type: tempo
        access: proxy
        url: *tempo_url
        isDefault: false
        jsonData:
          httpMethod: GET
          serviceMap:
            datasourceUid: prometheus
          tracesToLogsV2:
            datasourceUid: loki
            spanStartTimeShift: "1h"
            spanEndTimeShift: "1h"
          lokiSearch:
            datasourceUid: loki

  prometheus:
    enabled: true
    prometheusSpec:
      retention: 15d
      walCompression: true
      enableAdminAPI: false

  kubeApiServer:
    enabled: true
  kubeControllerManager:
    enabled: true
  kubeScheduler:
    enabled: true
  kubeEtcd:
    enabled: true
  kubeProxy:
    enabled: true
  kubeStateMetrics:
    enabled: true
  nodeExporter:
    enabled: true

# ========== Loki (alias: loki) ==========
loki:
  enabled: true
  fullnameOverride: loki

  deploymentMode: SingleBinary
  singleBinary: { replicas: 1 }
  simpleScalable: { replicas: 0 }
  backend: { enabled: false, replicas: 0 }
  read:    { enabled: false, replicas: 0 }
  write:   { enabled: false, replicas: 0 }

  # 余計な周辺機能は学習用にオフ
  chunksCache:  { enabled: false }
  resultsCache: { enabled: false }
  gateway:      { enabled: false }
  canary:       { enabled: false }

  service: { type: ClusterIP, port: 3100 }

  persistence:
    enabled: false
    size: 5Gi

  loki:
    auth_enabled: false
    commonConfig:
      path_prefix: /var/loki
      replication_factor: 1
    limits_config:
      allow_structured_metadata: false

    # ← common.storage に複数 backend が出ないよう、このブロックは最小化
    storage:
      type: filesystem
      filesystem: {}
      bucketNames:
        chunks: loki-chunks
        ruler:  loki-ruler
        admin:  loki-admin

    schemaConfig:
      configs:
        - from: 2020-10-24
          store: boltdb-shipper
          object_store: filesystem
          schema: v13
          index:
            prefix: index_
            period: 24h
        - from: "2025-10-17"
          store: tsdb
          object_store: filesystem
          schema: v13
          index:
            prefix: index_
            period: 24h

    storage_config:
      boltdb_shipper:
        active_index_directory: /var/loki/index
        cache_location: /var/loki/index_cache
      filesystem:
        directory: /var/loki/chunks

    query_range:
      cache_results: false

# ========== Tempo (alias: tempo) ==========
tempo:
  enabled: true
  fullnameOverride: tempo
  persistence:
    enabled: false

# ========== OpenTelemetry Collector (alias: otelcol) ==========
otelcol:
  enabled: true
  fullnameOverride: otelcol
  mode: deployment
  replicaCount: 1
  image:
    repository: otel/opentelemetry-collector-contrib
    tag: "0.137.0"
    pullPolicy: IfNotPresent

  service:
    type: ClusterIP

  ports:
    otlp:
      enabled: true
      containerPort: 4317
      servicePort: 4317
      protocol: TCP
    otlp-http:
      enabled: true
      containerPort: 4318
      servicePort: 4318
      protocol: TCP

  config:
    receivers:
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:4317
          http:
            endpoint: 0.0.0.0:4318

    processors:
      batch: {}

    exporters:
      # Traces → Tempo（gRPC）
      otlp/tempo:
        endpoint: "tempo.monitoring.svc:4317"
        tls:
          insecure: true

      # Logs → Loki（OTLP/HTTP）
      otlphttp/loki:
        endpoint: http://loki.monitoring.svc:3100/otlp/v1/logs

    service:
      extensions: [health_check]
      pipelines:
        traces:
          receivers: [otlp]
          processors: [batch]
          exporters: [otlp/tempo]
        logs:
          receivers: [otlp]
          processors: [batch]
          exporters: [otlphttp/loki]

    extensions:
      health_check:
        endpoint: 0.0.0.0:13133
      pprof: {}
      zpages: {}

monitors:
  prometheus:
    namespace: monitoring
    labels:
      release: cno-mon

  common:
    scrapeInterval: 30s
    scrapeTimeout: 10s
    scheme: http

  operators:
    enabled: true
    targets:
      - name: cno-operator
        kind: ServiceMonitor
        namespace: cno-operator
        selector:
          matchLabels:
            app.kubernetes.io/name: cno-operator
        endpoints:
          - port: http-metrics
            path: /metrics
            interval: 30s

  apps:
    enabled: true
    targets:
      - name: grafana
        kind: ServiceMonitor
        namespace: monitoring
        selector:
          matchLabels:
            app.kubernetes.io/name: grafana
        endpoints:
          - port: http
            path: /metrics

  argocd:
    enabled: true
    namespace: argocd
    targets:
      - name: argocd-server
        kind: PodMonitor
        namespace: argocd
        podSelector:
          matchLabels:
            app.kubernetes.io/name: argocd-server
        endpoints:
          - port: metrics
            path: /metrics
      - name: argocd-repo-server
        kind: PodMonitor
        namespace: argocd
        podSelector:
          matchLabels:
            app.kubernetes.io/name: argocd-repo-server
        endpoints:
          - port: metrics
            path: /metrics

alerts:
  enabled: false

  labels:
    team: cno
    grpcService: grpc
    k8sService: k8s
    operatorService: operator

  thresholds:
    grpcErrorRate: 0.05
    grpcP95: 0.20
    podRestartBurst: 3
    minTargetsDown: 1

  durations:
    grpcErrorRate: 10m
    grpcP95: 10m
    podRestartBurst: 10m
    minTargetsDown: 5m

  severities:
    grpcErrorRate: warning
    grpcP95: warning
    podRestartBurst: warning
    minTargetsDown: critical

  alertmanager:
    mode: inline
    group_wait: 30s
    group_interval: 5m
    repeat_interval: 1h

  slack:
    webhookUrlSecret:
      name: slack-webhook
      key: url
    channel: "#observability"
    username: "Alertmanager"
    sendResolved: true

networkPolicy:
  enabled: true

  namespaceSelector: {}

  selectors:
    prometheus:
      matchLabels:
        app.kubernetes.io/name: prometheus
    alertmanager:
      matchLabels:
        app.kubernetes.io/name: alertmanager
    grafana:
      matchLabels:
        app.kubernetes.io/name: grafana
    loki:
      matchLabels:
        app.kubernetes.io/name: loki
    tempo:
      matchLabels:
        app.kubernetes.io/name: tempo
    otelcol:
      matchLabels:
        app.kubernetes.io/name: opentelemetry-collector
    kubeStateMetrics:
      matchLabels:
        app.kubernetes.io/name: kube-state-metrics
    nodeExporter:
      matchLabels:
        app.kubernetes.io/name: node-exporter

  ports:
    prometheusHttp: 9090
    alertmanagerHttp: 9093
    grafanaHttp: 3000
    lokiHttp: 3100
    tempoHttp: 3200
    otlpGrpc: 4317
    otlpHttp: 4318
    kubeStateMetricsHttp: 8080
    nodeExporterMetrics: 9100

  otelcol:
    allowFromNamespaces:
      - {}

  prometheus:
    allowScrape:
      kubeStateMetrics : true
      nodeExporter : true
      selfFederate : false
      alertmanager : true

subcharts:
  kubePrometheusStack:
    kubeControllerManager:
      enabled: false
    kubeScheduler:
      enabled: false
    kubeProxy:
      enabled: false
    kubeEtcd:
      enabled: false
